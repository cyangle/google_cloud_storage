#  Cloud Storage JSON API
#
# Stores and retrieves potentially large, immutable data objects.
#
# The version of the OpenAPI document: v1
#
# Generated by: https://openapi-generator.tech
# OpenAPI Generator version: 5.3.1-SNAPSHOT
#

require "uri"

module GoogleCloudStorage
  class ObjectsApi
    property api_client : ApiClient

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end

    # Concatenates a list of existing objects into a new object in the same bucket.
    # @param destination_bucket [String] Name of the bucket containing the source objects. The destination object is stored in this bucket.
    # @param destination_object [String] Name of the new object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Object]
    def storage_objects_compose(*, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_metageneration_match : String? = nil, kms_key_name : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, compose_request : ComposeRequest? = nil)
      data, _status_code, _headers = storage_objects_compose_with_http_info(destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_metageneration_match: if_metageneration_match, kms_key_name: kms_key_name, provisional_user_project: provisional_user_project, user_project: user_project, compose_request: compose_request)
      data
    end

    # Concatenates a list of existing objects into a new object in the same bucket.
    # @param destination_bucket [String] Name of the bucket containing the source objects. The destination object is stored in this bucket.
    # @param destination_object [String] Name of the new object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_compose_with_http_info(*, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_metageneration_match : String? = nil, kms_key_name : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, compose_request : ComposeRequest? = nil)
      request = build_api_request_for_storage_objects_compose(destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_metageneration_match: if_metageneration_match, kms_key_name: kms_key_name, provisional_user_project: provisional_user_project, user_project: user_project, compose_request: compose_request)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_compose\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Concatenates a list of existing objects into a new object in the same bucket.
    # @param destination_bucket [String] Name of the bucket containing the source objects. The destination object is stored in this bucket.
    # @param destination_object [String] Name of the new object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_compose(*, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_metageneration_match : String? = nil, kms_key_name : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, compose_request : ComposeRequest? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_compose(destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_metageneration_match: if_metageneration_match, kms_key_name: kms_key_name, provisional_user_project: provisional_user_project, user_project: user_project, compose_request: compose_request).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_compose(*, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_metageneration_match : String? = nil, kms_key_name : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, compose_request : ComposeRequest? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_compose ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !destination_predefined_acl.nil? && !destination_predefined_acl.null? && !allowable_values.includes?(destination_predefined_acl)
        raise ArgumentError.new("invalid value for \"destination_predefined_acl\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{destinationBucket}/o/{destinationObject}/compose".sub("{" + "destinationBucket" + "}", URI.encode_path(destination_bucket.to_s)).sub("{" + "destinationObject" + "}", URI.encode_path(destination_object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["destinationPredefinedAcl"] = destination_predefined_acl.to_s if !destination_predefined_acl.nil? && !destination_predefined_acl.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["kmsKeyName"] = kms_key_name.to_s if !kms_key_name.nil? && !kms_key_name.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = compose_request.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_compose",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Copies a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.
    # @return [Object]
    def storage_objects_copy(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil)
      data, _status_code, _headers = storage_objects_copy_with_http_info(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, source_generation: source_generation, user_project: user_project, object: object)
      data
    end

    # Copies a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_copy_with_http_info(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil)
      request = build_api_request_for_storage_objects_copy(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, source_generation: source_generation, user_project: user_project, object: object)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_copy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Copies a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.
    # @return nil
    def storage_objects_copy(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_copy(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, source_generation: source_generation, user_project: user_project, object: object).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_copy(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_copy ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !destination_predefined_acl.nil? && !destination_predefined_acl.null? && !allowable_values.includes?(destination_predefined_acl)
        raise ArgumentError.new("invalid value for \"destination_predefined_acl\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{sourceBucket}/o/{sourceObject}/copyTo/b/{destinationBucket}/o/{destinationObject}".sub("{" + "sourceBucket" + "}", URI.encode_path(source_bucket.to_s)).sub("{" + "sourceObject" + "}", URI.encode_path(source_object.to_s)).sub("{" + "destinationBucket" + "}", URI.encode_path(destination_bucket.to_s)).sub("{" + "destinationObject" + "}", URI.encode_path(destination_object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["destinationKmsKeyName"] = destination_kms_key_name.to_s if !destination_kms_key_name.nil? && !destination_kms_key_name.null?
      query_params["destinationPredefinedAcl"] = destination_predefined_acl.to_s if !destination_predefined_acl.nil? && !destination_predefined_acl.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["ifSourceGenerationMatch"] = if_source_generation_match.to_s if !if_source_generation_match.nil? && !if_source_generation_match.null?
      query_params["ifSourceGenerationNotMatch"] = if_source_generation_not_match.to_s if !if_source_generation_not_match.nil? && !if_source_generation_not_match.null?
      query_params["ifSourceMetagenerationMatch"] = if_source_metageneration_match.to_s if !if_source_metageneration_match.nil? && !if_source_metageneration_match.null?
      query_params["ifSourceMetagenerationNotMatch"] = if_source_metageneration_not_match.to_s if !if_source_metageneration_not_match.nil? && !if_source_metageneration_not_match.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["sourceGeneration"] = source_generation.to_s if !source_generation.nil? && !source_generation.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = object.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_copy",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [nil]
    def storage_objects_delete(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      storage_objects_delete_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, provisional_user_project: provisional_user_project, user_project: user_project)
      nil
    end

    # Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def storage_objects_delete_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      request = build_api_request_for_storage_objects_delete(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, provisional_user_project: provisional_user_project, user_project: user_project)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_delete\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return nil, status_code, headers
    end

    # Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_delete(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_delete(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, provisional_user_project: provisional_user_project, user_project: user_project).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_delete(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_delete ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"DELETE",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_delete",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Retrieves an object or its metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Object]
    def storage_objects_get(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      data, _status_code, _headers = storage_objects_get_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project)
      data
    end

    # Retrieves an object or its metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_get_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      request = build_api_request_for_storage_objects_get(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_get\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Retrieves an object or its metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_get(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_get(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_get(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_get ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_get",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Returns an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Policy]
    def storage_objects_get_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      data, _status_code, _headers = storage_objects_get_iam_policy_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project)
      data
    end

    # Returns an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Policy, Integer, Hash)>] Policy data, response status code and response headers
    def storage_objects_get_iam_policy_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      request = build_api_request_for_storage_objects_get_iam_policy(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_get_iam_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Policy.from_nason(data), status_code, headers
    end

    # Returns an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_get_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_get_iam_policy(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_get_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_get_iam_policy ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}/iam".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_get_iam_policy",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Stores a new object and metadata.
    # @param bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @return [Object]
    def storage_objects_insert(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, content_encoding : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, kms_key_name : String? = nil, name : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object : Object? = nil)
      data, _status_code, _headers = storage_objects_insert_with_http_info(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, content_encoding: content_encoding, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, kms_key_name: kms_key_name, name: name, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object: object)
      data
    end

    # Stores a new object and metadata.
    # @param bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_insert_with_http_info(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, content_encoding : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, kms_key_name : String? = nil, name : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object : Object? = nil)
      request = build_api_request_for_storage_objects_insert(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, content_encoding: content_encoding, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, kms_key_name: kms_key_name, name: name, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object: object)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_insert\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Stores a new object and metadata.
    # @param bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @return nil
    def storage_objects_insert(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, content_encoding : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, kms_key_name : String? = nil, name : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object : Object? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_insert(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, content_encoding: content_encoding, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, kms_key_name: kms_key_name, name: name, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object: object).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_insert(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, content_encoding : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, kms_key_name : String? = nil, name : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object : Object? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_insert ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !predefined_acl.nil? && !predefined_acl.null? && !allowable_values.includes?(predefined_acl)
        raise ArgumentError.new("invalid value for \"predefined_acl\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["contentEncoding"] = content_encoding.to_s if !content_encoding.nil? && !content_encoding.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["kmsKeyName"] = kms_key_name.to_s if !kms_key_name.nil? && !kms_key_name.null?
      query_params["name"] = name.to_s if !name.nil? && !name.null?
      query_params["predefinedAcl"] = predefined_acl.to_s if !predefined_acl.nil? && !predefined_acl.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/octet-stream"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = object.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_insert",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Retrieves a list of objects matching the criteria.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return [Objects]
    def storage_objects_list(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil)
      data, _status_code, _headers = storage_objects_list_with_http_info(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions)
      data
    end

    # Retrieves a list of objects matching the criteria.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return [Array<(Objects, Integer, Hash)>] Objects data, response status code and response headers
    def storage_objects_list_with_http_info(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil)
      request = build_api_request_for_storage_objects_list(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Objects.from_nason(data), status_code, headers
    end

    # Retrieves a list of objects matching the criteria.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return nil
    def storage_objects_list(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_list(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_list(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_list ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      if @api_client.config.client_side_validation && !max_results.nil? && max_results < 0
        raise ArgumentError.new("invalid value for \"max_results\" when calling ObjectsApi.storage_objects_list, must be greater than or equal to 0.")
      end

      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["delimiter"] = delimiter.to_s if !delimiter.nil? && !delimiter.null?
      query_params["endOffset"] = end_offset.to_s if !end_offset.nil? && !end_offset.null?
      query_params["includeTrailingDelimiter"] = include_trailing_delimiter.to_s if !include_trailing_delimiter.nil? && !include_trailing_delimiter.null?
      query_params["maxResults"] = max_results.to_s if !max_results.nil? && !max_results.null?
      query_params["pageToken"] = page_token.to_s if !page_token.nil? && !page_token.null?
      query_params["prefix"] = prefix.to_s if !prefix.nil? && !prefix.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["startOffset"] = start_offset.to_s if !start_offset.nil? && !start_offset.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?
      query_params["versions"] = versions.to_s if !versions.nil? && !versions.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_list",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Patches an object's metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Object]
    def storage_objects_patch(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil)
      data, _status_code, _headers = storage_objects_patch_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2)
      data
    end

    # Patches an object&#39;s metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_patch_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil)
      request = build_api_request_for_storage_objects_patch(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_patch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Patches an object&#39;s metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_patch(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_patch(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_patch(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_patch ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !predefined_acl.nil? && !predefined_acl.null? && !allowable_values.includes?(predefined_acl)
        raise ArgumentError.new("invalid value for \"predefined_acl\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["predefinedAcl"] = predefined_acl.to_s if !predefined_acl.nil? && !predefined_acl.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = object2.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"PATCH",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_patch",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Rewrites a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [RewriteResponse]
    def storage_objects_rewrite(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, max_bytes_rewritten_per_call : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, rewrite_token : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil)
      data, _status_code, _headers = storage_objects_rewrite_with_http_info(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, max_bytes_rewritten_per_call: max_bytes_rewritten_per_call, projection: projection, provisional_user_project: provisional_user_project, rewrite_token: rewrite_token, source_generation: source_generation, user_project: user_project, object: object)
      data
    end

    # Rewrites a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(RewriteResponse, Integer, Hash)>] RewriteResponse data, response status code and response headers
    def storage_objects_rewrite_with_http_info(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, max_bytes_rewritten_per_call : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, rewrite_token : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil)
      request = build_api_request_for_storage_objects_rewrite(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, max_bytes_rewritten_per_call: max_bytes_rewritten_per_call, projection: projection, provisional_user_project: provisional_user_project, rewrite_token: rewrite_token, source_generation: source_generation, user_project: user_project, object: object)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_rewrite\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return RewriteResponse.from_nason(data), status_code, headers
    end

    # Rewrites a source object to a destination object. Optionally overrides metadata.
    # @param source_bucket [String] Name of the bucket in which to find the source object.
    # @param source_object [String] Name of the source object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param destination_bucket [String] Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
    # @param destination_object [String] Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_rewrite(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, max_bytes_rewritten_per_call : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, rewrite_token : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_rewrite(source_bucket: source_bucket, source_object: source_object, destination_bucket: destination_bucket, destination_object: destination_object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, destination_kms_key_name: destination_kms_key_name, destination_predefined_acl: destination_predefined_acl, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, if_source_generation_match: if_source_generation_match, if_source_generation_not_match: if_source_generation_not_match, if_source_metageneration_match: if_source_metageneration_match, if_source_metageneration_not_match: if_source_metageneration_not_match, max_bytes_rewritten_per_call: max_bytes_rewritten_per_call, projection: projection, provisional_user_project: provisional_user_project, rewrite_token: rewrite_token, source_generation: source_generation, user_project: user_project, object: object).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_rewrite(*, source_bucket : String, source_object : String, destination_bucket : String, destination_object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, destination_kms_key_name : String? = nil, destination_predefined_acl : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, if_source_generation_match : String? = nil, if_source_generation_not_match : String? = nil, if_source_metageneration_match : String? = nil, if_source_metageneration_not_match : String? = nil, max_bytes_rewritten_per_call : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, rewrite_token : String? = nil, source_generation : String? = nil, user_project : String? = nil, object : Object? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_rewrite ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !destination_predefined_acl.nil? && !destination_predefined_acl.null? && !allowable_values.includes?(destination_predefined_acl)
        raise ArgumentError.new("invalid value for \"destination_predefined_acl\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{sourceBucket}/o/{sourceObject}/rewriteTo/b/{destinationBucket}/o/{destinationObject}".sub("{" + "sourceBucket" + "}", URI.encode_path(source_bucket.to_s)).sub("{" + "sourceObject" + "}", URI.encode_path(source_object.to_s)).sub("{" + "destinationBucket" + "}", URI.encode_path(destination_bucket.to_s)).sub("{" + "destinationObject" + "}", URI.encode_path(destination_object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["destinationKmsKeyName"] = destination_kms_key_name.to_s if !destination_kms_key_name.nil? && !destination_kms_key_name.null?
      query_params["destinationPredefinedAcl"] = destination_predefined_acl.to_s if !destination_predefined_acl.nil? && !destination_predefined_acl.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["ifSourceGenerationMatch"] = if_source_generation_match.to_s if !if_source_generation_match.nil? && !if_source_generation_match.null?
      query_params["ifSourceGenerationNotMatch"] = if_source_generation_not_match.to_s if !if_source_generation_not_match.nil? && !if_source_generation_not_match.null?
      query_params["ifSourceMetagenerationMatch"] = if_source_metageneration_match.to_s if !if_source_metageneration_match.nil? && !if_source_metageneration_match.null?
      query_params["ifSourceMetagenerationNotMatch"] = if_source_metageneration_not_match.to_s if !if_source_metageneration_not_match.nil? && !if_source_metageneration_not_match.null?
      query_params["maxBytesRewrittenPerCall"] = max_bytes_rewritten_per_call.to_s if !max_bytes_rewritten_per_call.nil? && !max_bytes_rewritten_per_call.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["rewriteToken"] = rewrite_token.to_s if !rewrite_token.nil? && !rewrite_token.null?
      query_params["sourceGeneration"] = source_generation.to_s if !source_generation.nil? && !source_generation.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = object.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_rewrite",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Updates an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Policy]
    def storage_objects_set_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, policy : Policy? = nil)
      data, _status_code, _headers = storage_objects_set_iam_policy_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project, policy: policy)
      data
    end

    # Updates an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Policy, Integer, Hash)>] Policy data, response status code and response headers
    def storage_objects_set_iam_policy_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, policy : Policy? = nil)
      request = build_api_request_for_storage_objects_set_iam_policy(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project, policy: policy)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_set_iam_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Policy.from_nason(data), status_code, headers
    end

    # Updates an IAM policy for the specified object.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_set_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, policy : Policy? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_set_iam_policy(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project, policy: policy).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_set_iam_policy(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, policy : Policy? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_set_iam_policy ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}/iam".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = policy.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"PUT",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_set_iam_policy",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Tests a set of permissions on the given object to see which, if any, are held by the caller.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param permissions [Array(String)] Permissions to test.
    # @return [TestIamPermissionsResponse]
    def storage_objects_test_iam_permissions(*, bucket : String, object : String, permissions : Array(String), alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      data, _status_code, _headers = storage_objects_test_iam_permissions_with_http_info(bucket: bucket, object: object, permissions: permissions, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project)
      data
    end

    # Tests a set of permissions on the given object to see which, if any, are held by the caller.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param permissions [Array(String)] Permissions to test.
    # @return [Array<(TestIamPermissionsResponse, Integer, Hash)>] TestIamPermissionsResponse data, response status code and response headers
    def storage_objects_test_iam_permissions_with_http_info(*, bucket : String, object : String, permissions : Array(String), alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil)
      request = build_api_request_for_storage_objects_test_iam_permissions(bucket: bucket, object: object, permissions: permissions, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_test_iam_permissions\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return TestIamPermissionsResponse.from_nason(data), status_code, headers
    end

    # Tests a set of permissions on the given object to see which, if any, are held by the caller.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @param permissions [Array(String)] Permissions to test.
    # @return nil
    def storage_objects_test_iam_permissions(*, bucket : String, object : String, permissions : Array(String), alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_test_iam_permissions(bucket: bucket, object: object, permissions: permissions, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, provisional_user_project: provisional_user_project, user_project: user_project).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_test_iam_permissions(*, bucket : String, object : String, permissions : Array(String), alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_test_iam_permissions ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}/iam/testPermissions".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["permissions"] = @api_client.build_collection_param(permissions, "multi") if !permissions.nil? && !permissions.null? && !permissions.empty?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = nil

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"GET",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_test_iam_permissions",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Updates an object's metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Object]
    def storage_objects_update(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil)
      data, _status_code, _headers = storage_objects_update_with_http_info(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2)
      data
    end

    # Updates an object&#39;s metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def storage_objects_update_with_http_info(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil)
      request = build_api_request_for_storage_objects_update(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_update\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Object.from_nason(data), status_code, headers
    end

    # Updates an object&#39;s metadata.
    # @param bucket [String] Name of the bucket in which the object resides.
    # @param object [String] Name of the object. For information about how to URL encode object names to be path safe, see Encoding URI Path Parts.
    # @return nil
    def storage_objects_update(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_update(bucket: bucket, object: object, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, generation: generation, if_generation_match: if_generation_match, if_generation_not_match: if_generation_not_match, if_metageneration_match: if_metageneration_match, if_metageneration_not_match: if_metageneration_not_match, predefined_acl: predefined_acl, projection: projection, provisional_user_project: provisional_user_project, user_project: user_project, object2: object2).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_update(*, bucket : String, object : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, generation : String? = nil, if_generation_match : String? = nil, if_generation_not_match : String? = nil, if_metageneration_match : String? = nil, if_metageneration_not_match : String? = nil, predefined_acl : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, user_project : String? = nil, object2 : Object? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_update ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      allowable_values = ["authenticatedRead", "bucketOwnerFullControl", "bucketOwnerRead", "private", "projectPrivate", "publicRead"]
      if @api_client.config.client_side_validation && !predefined_acl.nil? && !predefined_acl.null? && !allowable_values.includes?(predefined_acl)
        raise ArgumentError.new("invalid value for \"predefined_acl\", must be one of #{allowable_values}")
      end
      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/{object}".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s)).sub("{" + "object" + "}", URI.encode_path(object.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["generation"] = generation.to_s if !generation.nil? && !generation.null?
      query_params["ifGenerationMatch"] = if_generation_match.to_s if !if_generation_match.nil? && !if_generation_match.null?
      query_params["ifGenerationNotMatch"] = if_generation_not_match.to_s if !if_generation_not_match.nil? && !if_generation_not_match.null?
      query_params["ifMetagenerationMatch"] = if_metageneration_match.to_s if !if_metageneration_match.nil? && !if_metageneration_match.null?
      query_params["ifMetagenerationNotMatch"] = if_metageneration_not_match.to_s if !if_metageneration_not_match.nil? && !if_metageneration_not_match.null?
      query_params["predefinedAcl"] = predefined_acl.to_s if !predefined_acl.nil? && !predefined_acl.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = object2.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"PUT",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_update",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end

    # Watch for changes on all objects in a bucket.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return [Channel]
    def storage_objects_watch_all(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil, channel : Channel? = nil)
      data, _status_code, _headers = storage_objects_watch_all_with_http_info(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions, channel: channel)
      data
    end

    # Watch for changes on all objects in a bucket.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return [Array<(Channel, Integer, Hash)>] Channel data, response status code and response headers
    def storage_objects_watch_all_with_http_info(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil, channel : Channel? = nil)
      request = build_api_request_for_storage_objects_watch_all(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions, channel: channel)

      data, status_code, headers = @api_client.execute_api_request(request)

      if @api_client.config.debugging
        Log.debug { "API called: ObjectsApi#storage_objects_watch_all\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}" }
      end

      return Channel.from_nason(data), status_code, headers
    end

    # Watch for changes on all objects in a bucket.
    # @param bucket [String] Name of the bucket in which to look for objects.
    # @return nil
    def storage_objects_watch_all(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil, channel : Channel? = nil, &block : Crest::Response ->)
      build_api_request_for_storage_objects_watch_all(bucket: bucket, alt: alt, fields: fields, key: key, oauth_token: oauth_token, pretty_print: pretty_print, quota_user: quota_user, user_ip: user_ip, delimiter: delimiter, end_offset: end_offset, include_trailing_delimiter: include_trailing_delimiter, max_results: max_results, page_token: page_token, prefix: prefix, projection: projection, provisional_user_project: provisional_user_project, start_offset: start_offset, user_project: user_project, versions: versions, channel: channel).execute(&block)
    end

    # @return Crest::Request
    def build_api_request_for_storage_objects_watch_all(*, bucket : String, alt : String? = nil, fields : String? = nil, key : String? = nil, oauth_token : String? = nil, pretty_print : Bool? = nil, quota_user : String? = nil, user_ip : String? = nil, delimiter : String? = nil, end_offset : String? = nil, include_trailing_delimiter : Bool? = nil, max_results : Int32? = nil, page_token : String? = nil, prefix : String? = nil, projection : String? = nil, provisional_user_project : String? = nil, start_offset : String? = nil, user_project : String? = nil, versions : Bool? = nil, channel : Channel? = nil) : Crest::Request
      if @api_client.config.debugging
        Log.debug { "Calling API: ObjectsApi.storage_objects_watch_all ..." }
      end
      allowable_values = ["json"]
      if @api_client.config.client_side_validation && !alt.nil? && !alt.null? && !allowable_values.includes?(alt)
        raise ArgumentError.new("invalid value for \"alt\", must be one of #{allowable_values}")
      end
      if @api_client.config.client_side_validation && !max_results.nil? && max_results < 0
        raise ArgumentError.new("invalid value for \"max_results\" when calling ObjectsApi.storage_objects_watch_all, must be greater than or equal to 0.")
      end

      allowable_values = ["full", "noAcl"]
      if @api_client.config.client_side_validation && !projection.nil? && !projection.null? && !allowable_values.includes?(projection)
        raise ArgumentError.new("invalid value for \"projection\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/b/{bucket}/o/watch".sub("{" + "bucket" + "}", URI.encode_path(bucket.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["alt"] = alt.to_s if !alt.nil? && !alt.null?
      query_params["fields"] = fields.to_s if !fields.nil? && !fields.null?
      query_params["key"] = key.to_s if !key.nil? && !key.null?
      query_params["oauth_token"] = oauth_token.to_s if !oauth_token.nil? && !oauth_token.null?
      query_params["prettyPrint"] = pretty_print.to_s if !pretty_print.nil? && !pretty_print.null?
      query_params["quotaUser"] = quota_user.to_s if !quota_user.nil? && !quota_user.null?
      query_params["userIp"] = user_ip.to_s if !user_ip.nil? && !user_ip.null?
      query_params["delimiter"] = delimiter.to_s if !delimiter.nil? && !delimiter.null?
      query_params["endOffset"] = end_offset.to_s if !end_offset.nil? && !end_offset.null?
      query_params["includeTrailingDelimiter"] = include_trailing_delimiter.to_s if !include_trailing_delimiter.nil? && !include_trailing_delimiter.null?
      query_params["maxResults"] = max_results.to_s if !max_results.nil? && !max_results.null?
      query_params["pageToken"] = page_token.to_s if !page_token.nil? && !page_token.null?
      query_params["prefix"] = prefix.to_s if !prefix.nil? && !prefix.null?
      query_params["projection"] = projection.to_s if !projection.nil? && !projection.null?
      query_params["provisionalUserProject"] = provisional_user_project.to_s if !provisional_user_project.nil? && !provisional_user_project.null?
      query_params["startOffset"] = start_offset.to_s if !start_offset.nil? && !start_offset.null?
      query_params["userProject"] = user_project.to_s if !user_project.nil? && !user_project.null?
      query_params["versions"] = versions.to_s if !versions.nil? && !versions.null?

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["application/json"])

      # form parameters
      form_params = nil

      # http body (model)
      post_body = channel.to_nason

      # auth_names
      auth_names = ["Oauth2", "Oauth2c"]

      @api_client.build_api_request(
        http_method: :"POST",
        path: local_var_path,
        operation: "ObjectsApi.storage_objects_watch_all",
        post_body: post_body,
        auth_names: auth_names,
        header_params: header_params,
        query_params: query_params,
        form_params: form_params
      )
    end
  end
end
